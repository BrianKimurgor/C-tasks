%{
#include <stdio.h>
#include <stdarg.h>
#include "bash.h"

/* some internal files generated by bison */
int yylex();
void yyerror(const char *s,...);
void yywarn(const char *s,...);

// data structure to hold a command
struct command {
    char *cmd;               // command name
    struct args *args;       // linked list of arguments
    struct redirs *redirs;   // linked list of redirections
};

// data structure to hold a linked list of arguments for a command
struct args {
    char *arg;
    struct args *next;
};

// data structure to hold a linked list of redirections for a command
struct redirs {
    int redir_token;
    char *filename;
    struct redirs *next;
};

/* include debugging code, in case we want it */
#define YYDEBUG 1

int lines = 0;
static int synerrors = 0;

%}

%union {
    char *string;
    struct command *pcmd;
    struct args *pargs;
    struct redirs *predir;
    int number;
}

%token EOLN PIPE 
%token INFILE 
%token OUTFILE OUTFILE_APPEND 
%token ERRFILE ERRFILE_APPEND 
%token <string> WORD

%type <pcmd> line cmd
%type <pargs> optargs arg
%type <predir> optredirs redir

%% 	/* parsing rules */
input : lines | ;

lines : oneline | oneline lines ;

oneline : line eoln { doline($1); }
        | eoln /* blank line, do nothing */
        | error eoln /* handle errors */
        ;

eoln : EOLN { ++lines; } ;

line : cmd { $$ = $1; }
     | cmd PIPE line { $$ = NULL; /* handle pipes later */ }
     ;

cmd : WORD optargs optredirs
     {
         // Allocate memory for a new command using MallocZ
         struct command *newcmd = (struct command *) MallocZ(sizeof(struct command));

         // Set the command name to the WORD token
         newcmd->cmd = $1;

         // Set args and redirs as NULL for now (to be handled later)
         newcmd->args = NULL;
         newcmd->redirs = NULL;

         // Debugging output
         printf("Command: '%s'\n", $1);

         // Return the new command structure
         $$ = newcmd;
     }
     ;

optargs : arg optargs { $$ = NULL; /* Placeholder */ }
        | { $$ = NULL; }
        ;

arg : WORD { /* Placeholder for arg logic */ }
    ;

optredirs : redir optredirs { $$ = NULL; /* Placeholder */ }
          | { $$ = NULL; }
          ;

redir : INFILE WORD { $$ = NULL; /* Placeholder for redir logic */ }
      ;

%%
void yyerror(const char *error_string, ...) {
    va_list ap;
    FILE *f = stdout;

    va_start(ap, error_string);
    ++synerrors;

    fprintf(f, "Error on line %d: ", lines);
    vfprintf(f, error_string, ap);
    fprintf(f, "\n");
    va_end(ap);
}

void *MallocZ(int nbytes) {
    char *ptr = malloc(nbytes);
    if (ptr == NULL) {
        perror("MallocZ failed, fatal\n");
        exit(66);
    }
    memset(ptr, '\00', nbytes);
    return ptr;
}
