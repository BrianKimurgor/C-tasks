%{
#include <stdio.h>
#include <stdarg.h>
#include "bash.h"
#include <stdlib.h>   // For exit()
#include <string.h>   // For memset()


/* some internal files generated by bison */
int yylex();
void yyerror(const char *s,...);
void yywarn(const char *s,...);





/* include debugging code, in case we want it */
#define YYDEBUG 1

int lines = 0;
static int synerrors = 0;

void *MallocZ(int nbytes);
void doline(struct command *cmd);
%}

%union {
    char *string;
    struct command *pcmd;
    struct args *pargs;
    struct redirs *predir;
    int number;
}

%token EOLN PIPE 
%token INFILE 
%token OUTFILE OUTFILE_APPEND 
%token ERRFILE ERRFILE_APPEND 
%token <string> WORD

%type <pcmd> line cmd
%type <pargs> optargs arg
%type <predir> optredirs redir

%% 	/* parsing rules */
input : lines | ;

lines : oneline | oneline lines ;

oneline : line eoln { doline($1); }
        | eoln /* blank line, do nothing */
        | error eoln /* handle errors */
        ;

eoln : EOLN { ++lines; } ;

line : cmd { $$ = $1; }
     | cmd PIPE line { 
         $$ = MallocZ(sizeof(struct command));
         $$->command = $1->command; // Correct field if you intended to set the command name
         $$->args = $1->args;
         $$->redirs = $1->redirs;
         $$->next = $3;  // Link the next command in the pipeline
     }
     ;

cmd : WORD optargs optredirs
     {
         // Allocate memory for a new command using MallocZ
         struct command *newcmd = (struct command *) MallocZ(sizeof(struct command));

         // Set the command name to the WORD token
        newcmd->command = $1;

         // Set arguments and redirections
         newcmd->args = $2;
         newcmd->redirs = $3;

         // Debugging output
         printf("Command: '%s'\n", $1);

         // Return the new command structure
         $$ = newcmd;
     }
     ;

optargs : arg optargs 
        {
            // Link new argument to the args list
            $1->next = $2;
            $$ = $1;
        }
        | { $$ = NULL; }
        ;

arg : WORD 
    {
        // Create new argument node
        struct args *newarg = MallocZ(sizeof(struct args));
        newarg->arg = $1;
        newarg->next = NULL;
        $$ = newarg;
    }
    ;

optredirs : redir optredirs
          {
              // Link new redirection to the redirs list
              $1->next = $2;
              $$ = $1;
          }
          | { $$ = NULL; }
          ;

redir : INFILE WORD 
      {
          // Create new redirection node for stdin
          struct redirs *newredir = MallocZ(sizeof(struct redirs));
          newredir->redir_token = INFILE;
          newredir->filename = $2;
          newredir->next = NULL;
          $$ = newredir;
      }
      | OUTFILE WORD 
      {
          // Create new redirection node for stdout
          struct redirs *newredir = MallocZ(sizeof(struct redirs));
          newredir->redir_token = OUTFILE;
          newredir->filename = $2;
          newredir->next = NULL;
          $$ = newredir;
      }
      | OUTFILE_APPEND WORD
      {
          // Create new redirection node for appending stdout
          struct redirs *newredir = MallocZ(sizeof(struct redirs));
          newredir->redir_token = OUTFILE_APPEND;
          newredir->filename = $2;
          newredir->next = NULL;
          $$ = newredir;
      }
      | ERRFILE WORD
      {
          // Create new redirection node for stderr
          struct redirs *newredir = MallocZ(sizeof(struct redirs));
          newredir->redir_token = ERRFILE;
          newredir->filename = $2;
          newredir->next = NULL;
          $$ = newredir;
      }
      | ERRFILE_APPEND WORD
      {
          // Create new redirection node for appending stderr
          struct redirs *newredir = MallocZ(sizeof(struct redirs));
          newredir->redir_token = ERRFILE_APPEND;
          newredir->filename = $2;
          newredir->next = NULL;
          $$ = newredir;
      }
      ;

%%

void yyerror(const char *error_string, ...) {
    va_list ap;
    FILE *f = stdout;

    va_start(ap, error_string);
    ++synerrors;

    fprintf(f, "Error on line %d: ", lines);
    vfprintf(f, error_string, ap);
    fprintf(f, "\n");
    va_end(ap);
}

void *MallocZ(int nbytes) {
    char *ptr = malloc(nbytes);
    if (ptr == NULL) {
        perror("MallocZ failed, fatal\n");
        exit(66);
    }
    memset(ptr, '\00', nbytes);
    return ptr;
}
